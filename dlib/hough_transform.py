# encoding: utf-8
# module dlib
# from /Users/henglongchay/face_recognition/lib/python3.7/site-packages/dlib.cpython-37m-darwin.so
# by generator 1.147
# no doc

# imports
import dlib.cuda as cuda # <module 'dlib.cuda'>
import dlib.image_dataset_metadata as image_dataset_metadata # <module 'dlib.image_dataset_metadata'>
import pybind11_builtins as __pybind11_builtins


class hough_transform(__pybind11_builtins.pybind11_object):
    """
    This object is a tool for computing the line finding version of the Hough transform 
    given some kind of edge detection image as input.  It also allows the edge pixels 
    to be weighted such that higher weighted edge pixels contribute correspondingly 
    more to the output of the Hough transform, allowing stronger edges to create 
    correspondingly stronger line detections in the final Hough transform.
    """
    def find_pixels_voting_for_lines(self, *args, **kwargs): # real signature unknown; restored from __doc__
        """
        find_pixels_voting_for_lines(*args, **kwargs)
        Overloaded function.
        
        1. find_pixels_voting_for_lines(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),uint8], box: dlib.rectangle, hough_points: dlib.points, angle_window_size: int=1, radius_window_size: int=1) -> list
        
        2. find_pixels_voting_for_lines(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),uint16], box: dlib.rectangle, hough_points: dlib.points, angle_window_size: int=1, radius_window_size: int=1) -> list
        
        3. find_pixels_voting_for_lines(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),uint32], box: dlib.rectangle, hough_points: dlib.points, angle_window_size: int=1, radius_window_size: int=1) -> list
        
        4. find_pixels_voting_for_lines(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),uint64], box: dlib.rectangle, hough_points: dlib.points, angle_window_size: int=1, radius_window_size: int=1) -> list
        
        5. find_pixels_voting_for_lines(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),int8], box: dlib.rectangle, hough_points: dlib.points, angle_window_size: int=1, radius_window_size: int=1) -> list
        
        6. find_pixels_voting_for_lines(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),int16], box: dlib.rectangle, hough_points: dlib.points, angle_window_size: int=1, radius_window_size: int=1) -> list
        
        7. find_pixels_voting_for_lines(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),int32], box: dlib.rectangle, hough_points: dlib.points, angle_window_size: int=1, radius_window_size: int=1) -> list
        
        8. find_pixels_voting_for_lines(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),int64], box: dlib.rectangle, hough_points: dlib.points, angle_window_size: int=1, radius_window_size: int=1) -> list
        
        9. find_pixels_voting_for_lines(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),float32], box: dlib.rectangle, hough_points: dlib.points, angle_window_size: int=1, radius_window_size: int=1) -> list
        
        10. find_pixels_voting_for_lines(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),float64], box: dlib.rectangle, hough_points: dlib.points, angle_window_size: int=1, radius_window_size: int=1) -> list
        
        requires 
            - box.width() == size 
            - box.height() == size 
            - for all valid i: 
                - rectangle(0,0,size-1,size-1).contains(hough_points[i]) == true 
                  (i.e. hough_points must contain points in the output Hough transform 
                  space generated by this object.) 
            - angle_window_size >= 1 
            - radius_window_size >= 1 
        ensures 
            - This function computes the Hough transform of the part of img contained 
              within box.  It does the same computation as __call__() defined above, 
              except instead of accumulating into an image we create an explicit list 
              of all the points in img that contributed to each line (i.e each point in 
              the Hough image). To do this we take a list of Hough points as input and 
              only record hits on these specifically identified Hough points.  A 
              typical use of find_pixels_voting_for_lines() is to first run the normal 
              Hough transform using __call__(), then find the lines you are interested 
              in, and then call find_pixels_voting_for_lines() to determine which 
              pixels in the input image belong to those lines. 
            - This routine returns a vector, CONSTITUENT_POINTS, with the following 
              properties: 
                - CONSTITUENT_POINTS.size == hough_points.size 
                - for all valid i: 
                    - Let HP[i] = centered_rect(hough_points[i], angle_window_size, radius_window_size) 
                    - Any point in img with a non-zero value that lies on a line 
                      corresponding to one of the Hough points in HP[i] is added to 
                      CONSTITUENT_POINTS[i].  Therefore, when this routine finishes, 
                      #CONSTITUENT_POINTS[i] will contain all the points in img that 
                      voted for the lines associated with the Hough accumulator bins in 
                      HP[i]. 
                    - #CONSTITUENT_POINTS[i].size == the number of points in img that 
                      voted for any of the lines HP[i] in Hough space.  Note, however, 
                      that if angle_window_size or radius_window_size are made so large 
                      that HP[i] overlaps HP[j] for i!=j then the overlapping regions 
                      of Hough space are assigned to HP[i] or HP[j] arbitrarily. 
                      That is, we treat HP[i] and HP[j] as disjoint even if their boxes 
                      overlap.  In this case, the overlapping region is assigned to 
                      either HP[i] or HP[j] in an arbitrary manner.
        
        11. find_pixels_voting_for_lines(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),uint8], hough_points: dlib.points, angle_window_size: int=1, radius_window_size: int=1) -> list
        
        12. find_pixels_voting_for_lines(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),uint16], hough_points: dlib.points, angle_window_size: int=1, radius_window_size: int=1) -> list
        
        13. find_pixels_voting_for_lines(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),uint32], hough_points: dlib.points, angle_window_size: int=1, radius_window_size: int=1) -> list
        
        14. find_pixels_voting_for_lines(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),uint64], hough_points: dlib.points, angle_window_size: int=1, radius_window_size: int=1) -> list
        
        15. find_pixels_voting_for_lines(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),int8], hough_points: dlib.points, angle_window_size: int=1, radius_window_size: int=1) -> list
        
        16. find_pixels_voting_for_lines(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),int16], hough_points: dlib.points, angle_window_size: int=1, radius_window_size: int=1) -> list
        
        17. find_pixels_voting_for_lines(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),int32], hough_points: dlib.points, angle_window_size: int=1, radius_window_size: int=1) -> list
        
        18. find_pixels_voting_for_lines(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),int64], hough_points: dlib.points, angle_window_size: int=1, radius_window_size: int=1) -> list
        
        19. find_pixels_voting_for_lines(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),float32], hough_points: dlib.points, angle_window_size: int=1, radius_window_size: int=1) -> list
        
        20. find_pixels_voting_for_lines(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),float64], hough_points: dlib.points, angle_window_size: int=1, radius_window_size: int=1) -> list
        
            performs: return find_pixels_voting_for_lines(img, get_rect(img), hough_points, angle_window_size, radius_window_size); 
        That is, just runs the routine on the whole input image.
        """
        pass

    def find_strong_hough_points(self, himg, float32=None, *args, **kwargs): # real signature unknown; NOTE: unreliably restored from __doc__ 
        """
        find_strong_hough_points(self: dlib.hough_transform, himg: numpy.ndarray[(rows,cols),float32], hough_count_thresh: float, angle_nms_thresh: float, radius_nms_thresh: float) -> dlib.points
        
        requires 
            - himg has size() rows and columns. 
            - angle_nms_thresh >= 0 
            - radius_nms_thresh >= 0 
        ensures 
            - This routine finds strong lines in a Hough transform and performs 
              non-maximum suppression on the detected lines.  Recall that each point in 
              Hough space is associated with a line. Therefore, this routine finds all 
              the pixels in himg (a Hough transform image) with values >= 
              hough_count_thresh and performs non-maximum suppression on the 
              identified list of pixels.  It does this by discarding lines that are 
              within angle_nms_thresh degrees of a stronger line or within 
              radius_nms_thresh distance (in terms of radius as defined by 
              get_line_properties()) to a stronger Hough point. 
            - The identified lines are returned as a list of coordinates in himg. 
            - The returned points are sorted so that points with larger Hough transform 
              values come first.
        """
        pass

    def get_best_hough_point(self, p, himg, float32=None): # real signature unknown; restored from __doc__
        """
        get_best_hough_point(self: dlib.hough_transform, p: dlib.point, himg: numpy.ndarray[(rows,cols),float32]) -> dlib.point
        
        requires 
            - himg has size rows and columns. 
            - rectangle(0,0,size-1,size-1).contains(p) == true 
        ensures 
            - This function interprets himg as a Hough image and p as a point in the 
              original image space.  Given this, it finds the maximum scoring line that 
              passes though p.  That is, it checks all the Hough accumulator bins in 
              himg corresponding to lines though p and returns the location with the 
              largest score.   
            - returns a point X such that get_rect(himg).contains(X) == true
        """
        pass

    def get_line(self, *args, **kwargs): # real signature unknown; restored from __doc__
        """
        get_line(*args, **kwargs)
        Overloaded function.
        
        1. get_line(self: dlib.hough_transform, p: dlib.point) -> dlib.line
        
        2. get_line(self: dlib.hough_transform, p: dlib.dpoint) -> dlib.line
        
        requires 
            - rectangle(0,0,size-1,size-1).contains(p) == true 
              (i.e. p must be a point inside the Hough accumulator array) 
        ensures 
            - returns the line segment in the original image space corresponding 
              to Hough transform point p.  
            - The returned points are inside rectangle(0,0,size-1,size-1).
        """
        pass

    def get_line_angle_in_degrees(self, *args, **kwargs): # real signature unknown; restored from __doc__
        """
        get_line_angle_in_degrees(*args, **kwargs)
        Overloaded function.
        
        1. get_line_angle_in_degrees(self: dlib.hough_transform, p: dlib.point) -> float
        
        2. get_line_angle_in_degrees(self: dlib.hough_transform, p: dlib.dpoint) -> float
        
        requires 
            - rectangle(0,0,size-1,size-1).contains(p) == true 
              (i.e. p must be a point inside the Hough accumulator array) 
        ensures 
            - returns the angle, in degrees, of the line corresponding to the Hough 
              transform point p.
        """
        pass

    def get_line_properties(self, *args, **kwargs): # real signature unknown; restored from __doc__
        """
        get_line_properties(*args, **kwargs)
        Overloaded function.
        
        1. get_line_properties(self: dlib.hough_transform, p: dlib.point) -> tuple
        
        2. get_line_properties(self: dlib.hough_transform, p: dlib.dpoint) -> tuple
        
        requires 
            - rectangle(0,0,size-1,size-1).contains(p) == true 
              (i.e. p must be a point inside the Hough accumulator array) 
        ensures 
            - Converts a point in the Hough transform space into an angle, in degrees, 
              and a radius, measured in pixels from the center of the input image. 
            - let ANGLE_IN_DEGREES == the angle of the line corresponding to the Hough 
              transform point p.  Moreover: -90 <= ANGLE_IN_DEGREES < 90. 
            - RADIUS == the distance from the center of the input image, measured in 
              pixels, and the line corresponding to the Hough transform point p. 
              Moreover: -sqrt(size*size/2) <= RADIUS <= sqrt(size*size/2) 
            - returns a tuple of (ANGLE_IN_DEGREES, RADIUS)
        """
        pass

    def __call__(self, *args, **kwargs): # real signature unknown; restored from __doc__
        """
        __call__(*args, **kwargs)
        Overloaded function.
        
        1. __call__(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),uint8], box: dlib.rectangle) -> numpy.ndarray[(rows,cols),float32]
        
        2. __call__(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),uint16], box: dlib.rectangle) -> numpy.ndarray[(rows,cols),float32]
        
        3. __call__(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),uint32], box: dlib.rectangle) -> numpy.ndarray[(rows,cols),float32]
        
        4. __call__(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),uint64], box: dlib.rectangle) -> numpy.ndarray[(rows,cols),float32]
        
        5. __call__(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),int8], box: dlib.rectangle) -> numpy.ndarray[(rows,cols),float32]
        
        6. __call__(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),int16], box: dlib.rectangle) -> numpy.ndarray[(rows,cols),float32]
        
        7. __call__(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),int32], box: dlib.rectangle) -> numpy.ndarray[(rows,cols),float32]
        
        8. __call__(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),int64], box: dlib.rectangle) -> numpy.ndarray[(rows,cols),float32]
        
        9. __call__(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),float32], box: dlib.rectangle) -> numpy.ndarray[(rows,cols),float32]
        
        10. __call__(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),float64], box: dlib.rectangle) -> numpy.ndarray[(rows,cols),float32]
        
        requires 
            - box.width() == size 
            - box.height() == size 
        ensures 
            - Computes the Hough transform of the part of img contained within box. 
              In particular, we do a grayscale version of the Hough transform where any 
              non-zero pixel in img is treated as a potential component of a line and 
              accumulated into the returned Hough accumulator image.  However, rather than 
              adding 1 to each relevant accumulator bin we add the value of the pixel 
              in img to each Hough accumulator bin.  This means that, if all the 
              pixels in img are 0 or 1 then this routine performs a normal Hough 
              transform.  However, if some pixels have larger values then they will be 
              weighted correspondingly more in the resulting Hough transform. 
            - The returned hough transform image will be size rows by size columns. 
            - The returned image is the Hough transform of the part of img contained in 
              box.  Each point in the Hough image corresponds to a line in the input box. 
              In particular, the line for hough_image[y][x] is given by get_line(point(x,y)).  
              Also, when viewing the Hough image, the x-axis gives the angle of the line 
              and the y-axis the distance of the line from the center of the box.  The 
              conversion between Hough coordinates and angle and pixel distance can be 
              obtained by calling get_line_properties().
        
        11. __call__(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),uint8]) -> numpy.ndarray[(rows,cols),float32]
        
        12. __call__(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),uint16]) -> numpy.ndarray[(rows,cols),float32]
        
        13. __call__(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),uint32]) -> numpy.ndarray[(rows,cols),float32]
        
        14. __call__(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),uint64]) -> numpy.ndarray[(rows,cols),float32]
        
        15. __call__(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),int8]) -> numpy.ndarray[(rows,cols),float32]
        
        16. __call__(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),int16]) -> numpy.ndarray[(rows,cols),float32]
        
        17. __call__(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),int32]) -> numpy.ndarray[(rows,cols),float32]
        
        18. __call__(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),int64]) -> numpy.ndarray[(rows,cols),float32]
        
        19. __call__(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),float32]) -> numpy.ndarray[(rows,cols),float32]
        
        20. __call__(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),float64]) -> numpy.ndarray[(rows,cols),float32]
        
            simply performs: return self(img, get_rect(img)).  That is, just runs the hough transform on the whole input image.
        """
        pass

    def __init__(self, size_): # real signature unknown; restored from __doc__
        """
        __init__(self: dlib.hough_transform, size_: int) -> None
        
        requires 
            - size_ > 0 
        ensures 
            - This object will compute Hough transforms that are size_ by size_ pixels.   
              This is in terms of both the Hough accumulator array size as well as the 
              input image size. 
            - size() == size_
        """
        pass

    size = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
    """returns the size of the Hough transforms generated by this object.  In particular, this object creates Hough transform images that are size by size pixels in size."""



